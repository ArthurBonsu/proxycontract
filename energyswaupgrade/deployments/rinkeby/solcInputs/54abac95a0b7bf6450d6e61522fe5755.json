{
  "language": "Solidity",
  "sources": {
    "contracts/Challenge.sol": {
      "content": "pragma solidity 0.8.2;\r\n// SPDX-License-Identifier: MIT\r\n//import './UniswapV2Factory.sol';\r\n//import './interfaces/IUniswapV2Factory.sol';\r\n//import './UniswapV2Pair.sol';\r\n\r\n\r\n\r\n\r\n////////////////////////////////////\r\n/// DO NOT USE IN PRODUCTION!!! ///\r\n///////////////////////////////////\r\n\r\n////////////////////////////\r\n/// GENERAL INSTRUCTIONS ///\r\n////////////////////////////\r\n\r\n// 1. AT THE TOP OF EACH CONTRACT FILE, PLEASE LIST GITHUB LINKS TO ANY AND ALL REPOS YOU BORROW FROM THAT YOU DO NOT EXPLICITLY IMPORT FROM ETC.\r\n// 2. PLEASE WRITE AS MUCH OR AS LITTLE CODE AS YOU THINK IS NEEDED TO COMPLETE THE TASK\r\n// 3. LIBRARIES AND UTILITY CONTRACTS (SUCH AS THOSE FROM OPENZEPPELIN) ARE FAIR GAME\r\n\r\n//////////////////////////////\r\n/// CHALLENGE INSTRUCTIONS ///\r\n//////////////////////////////\r\n\r\n// 1. Fill in the contract's functions so that the unit tests pass in tests/Challenge.spec.ts\r\n// 2. Please be overly explicit with your code comments\r\n// 3. Since unit tests are prewritten, please do not rename functions or variables\r\n\r\n\r\n\r\n\r\n\r\ncontract Incrementor {\r\n  // We match the Incrementor contract to match that of Challenge\r\n  // We set the values as private since call Challenge will pass a delegate call for internal operations\r\n  \r\n  uint256 private y;\r\n  uint256 private z;\r\n  uint256 private x;\r\n  \r\n  //We obtain address of Incrementor for use in Challenge\r\n  //Address becomes easily retrievable without instantiating instance\r\n  //Address is set to public for easy retrieval in Challenge\r\n  address public incrementaddress = address(this);\r\n\r\n  // We make a setter to contract\r\n  //Increment function set to retreve uint256 for x\r\n  function incrementX(uint256 _x) external  returns(uint256) {\r\n      x=_x;\r\n     \r\n   \r\n    \r\n    return(x);   \r\n  }\r\n  //Increment function set to retreve uint256 for y      \r\n  function incrementY(uint256 _y) external  returns (uint256) {\r\n     y=_y;\r\n    return(y);\r\n  }\r\n //Increment function set to retreve uint256 for z\r\n  function incrementZ(uint256 _z) external  returns (uint256) {\r\n   \r\n        z=_z;\r\n    \r\n    return(z);    \r\n  }\r\n}\r\n\r\n//Challenge contract inherit incrementor and uniswap\r\n//Incrementor is defined first as base contract\r\ncontract Challenge is Incrementor  {\r\n  // We rearrange the state -variables of Challenge to match that of contract Increment \r\n \r\naddress   tokenowner = msg.sender;\r\n\r\n \r\n  uint256 public y;\r\n  uint256 public z;\r\n  uint256 public x;\r\n   constructor () {\r\n\r\n   }\r\n   Incrementor _inc = new Incrementor();\r\n   \r\n  address  Incrementoraddress = address(_inc); \r\n  \r\n  address public factory;\r\n  \r\n  // @dev delegate incrementX to the Incrementor contract below\r\n  // @param inc address to delegate increment call to\r\n  \r\n  function incrementX(address incaddress, uint256 _x) external returns(uint) {\r\n   Incrementoraddress = incaddress;\r\n   x=_x;\r\n  // We pass in a delegate call to return a boolean value of success and a string of data\r\n   \r\n   bytes memory payload = abi.encodeWithSignature(\"incrementX(uint256)\", x);\r\n  \r\n \r\n  (bool success, bytes memory returnData) = Incrementoraddress.delegatecall(payload);\r\n   require(success);\r\n \r\n // Alternative method for calling the delegate call\r\n /*\r\n    (bool success, bytes memory data) = inc.delegatecall(\r\n // We encode the signature of the function\r\n      abi.encodeWithSignature(\"incrementX(uint256)\",_x )\r\n    );\r\n    */\r\n    return(x);\r\n  }\r\n \r\n  // @dev delegate incrementY to the Incrementor contract below\r\n  // @param inc address to delegate increment call to\r\n  // Variable names just for comprehensive purpose\r\n  //\r\n  function incrementY(address incaddress, uint _y) external returns(uint) {\r\n    y= _y;\r\n       Incrementoraddress = incaddress;\r\n  // We pass in a delegate call to return a boolean value of success and a string of data\r\n    (bool success, bytes memory data) = Incrementoraddress.delegatecall(\r\n \r\n  // We encode the signature of the function\r\n      abi.encodeWithSignature(\"incrementY(uint256)\",y )\r\n    );\r\n    return(y);\r\n  }\r\n  \r\n\r\n  // @dev delegate incrementZ to the Incrementor contract below\r\n  // @param inc address to delegate increment call to\r\n\r\n  function incrementZ(address incaddress, uint _z) external returns(uint returnz){\r\n   z=_z;\r\n   Incrementoraddress = incaddress;  \r\n  \r\n  // @We pass in a delegate call to return a boolean value of success and a string of data\r\n    (bool success, bytes memory data) = Incrementoraddress.delegatecall(\r\n  // @We encode the signature of the function\r\n      abi.encodeWithSignature(\"incrementZ(uint256)\",z )\r\n    );\r\n    return(z);\r\n  }\r\n  \r\n\r\n  // @dev determines if argument account is a contract or not\r\n  // @param account address to evaluate\r\n  // @return bool if account is contract or not\r\n   // size of code on an address from the EVM returning an opcode   \r\n  // assembly language for returning size of opcode  \r\n  // if size is greater than 0 resolve contract\r\n  // Need to pad size to 32\r\n  function isContract(address account) external returns(bool) {\r\n \r\n    uint256 codeLength;\r\n\r\n    assembly {codeLength := extcodesize(account)}\r\n    return (codeLength == 0 ? true : false);\r\n\r\n  \r\n  }\r\n\r\n  // @dev converts address to uint256\r\n  // @param account address to convert\r\n  // @return uint256\r\n  //from solidity 0.8.0 and above this method is used for typecasting\r\n  function addressToUint256(address account) external pure returns (uint256 _account) {\r\n          uint256 num = 0;\r\n           num =      uint256(uint160(address(account)));\r\n          return(num);\r\n }\r\n         \r\n\r\n\r\n\r\n  // @dev converts uint256 to address\r\n  // @param num uint256 number to convert\r\n  // @return address\r\n  // We return the value by abi.encoding address to byte\r\n  // We then turn into an address to retrive address value\r\n  function uint256ToAddress(uint256 num) public pure returns (address) {\r\n              \r\n       //  bytes32  bytenumber;\r\n             \r\n        address addressnumber;\r\n        \r\n        uint integernum = 0;\r\n        integernum = num;\r\n        bytes memory addressbytes = abi.encodePacked(integernum);\r\n         addressnumber = bytesToAddress(addressbytes);\r\n\r\n       \r\n       //  bytenumber = convertfromuinttobytes(num);\r\n         \r\n    return (addressnumber);\r\n  }\r\n\r\n  \r\n  // function set to change from uint to bytes32\r\nfunction convertfromuinttobytes(uint256 n) public returns (bytes32) {\r\n    return bytes32(n);\r\n}\r\n\r\n// function for changing address to bytes memory\r\n// We use assembly language to turn into a sizeable array of bytes before we can operate with to address in future\r\n\r\nfunction toBytes(address a) public pure returns (bytes memory b){\r\n    assembly {\r\n        let m := mload(0x40)\r\n        a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n        mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n        mstore(0x40, add(m, 52))\r\n        b := m\r\n   }\r\n}\r\n\r\n // Directly coverts from bytes to address, called in functions to help to typecast\r\n function bytesToAddress(bytes memory source) public pure returns(address addr) {\r\n        assembly {\r\n            \r\n            addr := mload(add(source, 0x14))\r\n        }\r\n    }\r\n\r\nfunction isHuman(address addr) external returns(bool) {\r\n    uint256 codeLength;\r\n\r\n    assembly {codeLength := extcodesize(addr)}\r\n    return (codeLength == 0 ? true : false);\r\n  }\r\n}\r\n\r\n// @dev computes uniswapV2 pair address\r\n// @param token0 address of first token in pair\r\n// @param token1 address of second token in pair\r\n// @return address of pair\r\n\r\n// function to get uniswap address\r\n// We inherit uniswap contract in order to call createPair\r\n // We pass in two tokens as addresses\r\n  \r\n  /*function getUniswapV2PairAddress(address token0, address token1)\r\n            \r\n    external\r\n    pure\r\n    returns (address)\r\n\r\n     \r\n  {\r\n     mapping(address => mapping(address => address)) memory getPair;\r\n    address[] memory  allPairs;\r\n\r\n      address pair = IUniswapV2Factory(msg.sender).createPair(token0, token1); \r\n\r\n\r\n*/\r\n      /*\r\n      require(tokenA ! = tokenB, 'UniswapV2: IDENTICAL ADDRESS '); \r\n      (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n      require ( token0 !=address(0), 'UniswapV2: ZERO_ADDRESS');\r\n      require (getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\r\n      bytes memory bytecode = type(UniswapV2Pair).creationCode; \r\n      bytes32 salt = keeccak256(abi.encodePacked(token0, token1))\r\n      assembly\r\n             {\r\n                  pair: = create2(0, add(bytecode, 32), mload(bytecode),salt)\r\n\r\n             }\r\n\r\n             IUniswapV2Pair(pair).initialize(token0, token1);\r\n             getPair[token0][token1] = pair;\r\n             getPair[token1][token0] = pair; \r\n             allPairs.push(pair); \r\n\r\n\r\n      require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\r\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\r\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        assembly {\r\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        IUniswapV2Pair(pair).initialize(token0, token1);\r\n        getPair[token0][token1] = pair;\r\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\r\n        allPairs.push(pair);\r\n        emit PairCreated(token0, token1, pair, allPairs.length);\r\n    }\r\n\r\n\r\n\r\n            address _pair;\r\n       \r\n             _pair =  IUniswapV2Factory(factory).createPair(token0, token1);\r\n           emit getUniswapV2PairAddresseventhere( token0,  token1, _pair);\r\n           return (_pair);\r\n     \r\n    \r\n    return (pair);\r\n\r\n*/\r\n  \r\n\r\n\r\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "pragma solidity >=0.7.0 <0.9.0;\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "pragma solidity >=0.7.0 <0.9.0;\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "pragma solidity >=0.7.0 <0.9.0;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}