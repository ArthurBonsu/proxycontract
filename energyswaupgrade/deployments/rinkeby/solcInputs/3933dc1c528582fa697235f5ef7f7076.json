{
  "language": "Solidity",
  "sources": {
    "contracts/RockPaperScissors.sol": {
      "content": "// Solidity files have to start with this pragma.\r\n// It will be used by the Solidity compiler to validate its version.\r\npragma solidity 0.8.2;\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport '../contracts/libraries/StringUtils.sol';\r\n\r\n\r\n// This is the main building block for smart contracts.\r\ncontract RockPaperScissors is    Ownable,ERC20 {\r\n    \r\n    // We set the 3 options players are required to choose\r\n    // We set it to constant to avoid wrong typo, safer for the contract\r\n    string constant   rock = \"rock\" ;\r\n    string constant  paper = \"paper\";\r\n    string constant  scissors = \"scissors\";\r\n    bool   rockchosen = false;\r\n    bool   scissorschosen = false;\r\n    bool   paperchosen = false;\r\n    string choicemade;\r\n    bool   setprevwinnings = false;\r\n    uint   public prev_gamestaked;\r\n    string private _tokenname =\"RPSTOKENS\";\r\n    string private _tokensymbol= \"RPS\";\r\n    address public _owner;\r\n    uint randNonce =0;\r\n    uint modulus =0;\r\n    uint _payfee=0;\r\n    uint maxWaitTime = 100;\r\n         \r\n  //  address  owner; \r\n // We decide to use the mapping instead of the struct approach\r\n       struct Game {\r\n             uint  gameid; \r\n             uint256 gamecount;\r\n             }\r\n\r\n       struct Players {\r\n              address payable playeraddress;\r\n              string playername;\r\n              uint256 playerscore;\r\n              uint256 playerbalance;\r\n              }\r\n       \r\n       struct PlayingGame{\r\n            uint playinggameid;\r\n            address payable playerininaddress;\r\n            bool gameover;    \r\n            uint256 gamescore; \r\n            uint256 playerscount;\r\n            uint duration;\r\n            }\r\n\r\n    // The fixed amount of tokens stored in an unsigned integer type variable.\r\n    uint256 public totalsupplytokens = 1000000;\r\n     \r\n    // An address type variable is used to store ethereum accounts taken from Ownable.sol\r\n   // address public owner;\r\n\r\n    // A mapping is a key/value map. Here we store each account balance.\r\n    // We store values that can be easy to have when we want to index values\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(bytes32 => bool)) playeringamecheck;\r\n    mapping(uint => mapping(address => uint)) prev_winning;\r\n    mapping(uint => mapping(address => uint)) gamewithplayer;     \r\n    mapping(uint => uint) gamesplayed;\r\n    mapping(address => address) playersplayed;\r\n    mapping(address => bool)paidforgames;\r\n       //We set into memory for cheaper access\r\n\r\n       mapping(uint=>Game) public _games;\r\n       mapping(address=>Players)public _playerstore;\r\n       mapping(uint=>PlayingGame) public _playinggames;\r\n\r\n    // We set the object for our tracks\r\n   Game  newgame;\r\n   Players  newplayerregistered;\r\n   PlayingGame  playerinthegame;\r\n    \r\n\r\n    // We push into storage \r\n    Game[] public gamesregistered;\r\n    Players[] public playersregistered;\r\n   PlayingGame[] public gameinplay;\r\n     \r\n    /**npn\r\n     * Contract initialization.\r\n     *\r\n     * The `constructor` is executed only once when the contract is created.\r\n     */\r\n\r\n\r\n      // modifier to check if caller is owner\r\n      \r\n      constructor(address __owner) ERC20(_tokenname, _tokensymbol ) {\r\n        _owner =__owner;\r\n        \r\n         totalSupply();\r\n         \r\n\r\n    }\r\n/*\r\n    modifier isOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == _owner , \"Caller is not owner\");\r\n      \r\n    }\r\n  */  \r\n    /**\r\n     * A function to transfer tokens.\r\n     *\r\n     * The `external` modifier makes a function *only* callable from outside\r\n     * the contract.\r\n     */\r\n\r\nfunction payfee(address payable sender, address payable owneraddress, uint256 amount) external payable returns(bool, bytes memory){\r\n              // Call returns a boolean value indicating success or failure.\r\n        // This is the current recommended method to use.\r\n         _owner =owneraddress;\r\n        _payfee = amount;\r\n     \r\n        require ( amount >= 10, \"Amount not enough to play!\");\r\n       // (bool sent, bytes memory data) = msg.sender.call{value: _payfee}(\"\");\r\n     //   require(sent, \"Failed to send Ether\");\r\n\r\n          (bool success,bytes memory data ) = _owner.call{value: _payfee}(\"\");\r\n            require(success, \"Check the amount sent as well\"); \r\n             paidforgames[sender]= true;\r\n    return (success,data);\r\n    }\r\n    function registerplayername(string memory _playername, address payable _playeraddress) external  returns(string memory, address){\r\n         \r\n              require(msg.sender == _owner , \"Caller is not owner\");\r\n         \r\n               if (paidforgames[_playeraddress] == true){\r\n            uint256 playerbalance =0;\r\n            playerbalance = balanceOf(_playeraddress);\r\n\r\n           if(playersplayed[_playeraddress] != _playeraddress){\r\n             //for player who has ever played before\r\n            playersplayed[_playeraddress] =_playeraddress ;\r\n            // for registered player\r\n\r\n                // Storing to memory\r\n            newplayerregistered = Players(_playeraddress,_playername, 0,playerbalance ); \r\n             _playerstore[_playeraddress].playeraddress = _playeraddress;\r\n             _playerstore[_playeraddress].playername = _playername;\r\n             _playerstore[_playeraddress].playerscore = 0;\r\n             _playerstore[_playeraddress].playerbalance = playerbalance;\r\n               \r\n                \r\n                // Storing to storage\r\n            playersregistered.push(newplayerregistered);                        \r\n\r\n            return (_playername,_playeraddress );\r\n     \r\n}\r\n}\r\n    }\r\n\r\n    \r\n\r\n    function registergame(uint _gameid) external  returns(uint){\r\n                uint256 i =0;\r\n                i++;\r\n           require(msg.sender == _owner , \"Caller is not owner\");\r\n    \r\n             uint256 gamecount = 0;\r\n         \r\n            if(gamesplayed[_gameid] != _gameid){\r\n           \r\n             gamesplayed[_gameid] = _gameid;\r\n              newgame = Game(_gameid,gamecount );\r\n\r\n              // Store into memory \r\n                _games[_gameid].gameid = _gameid;\r\n                _games[_gameid].gamecount = i;\r\n                \r\n             \r\n              gamesregistered.push(newgame);\r\n              return (_gameid);\r\n             }\r\n         \r\n    }\r\n\r\n\r\n// function -check if registered\r\n// function -check if game is registered\r\n        \r\n            \r\n\r\n        //stakeawards\r\n        //add to previous winnings\r\n    function setplayinggame(uint _gameid, address payable playersaddress) internal returns(uint, address) {\r\n           uint _playerscount =0;\r\n           _playerscount++;\r\n             //Game receipt\r\n          // increase nonce\r\n       require(msg.sender == _owner , \"Caller is not owner\");\r\n         uint __gameid =0;\r\n         __gameid = _gameid;\r\n         randNonce; \r\n         modulus= 100;\r\n        __gameid = uint(keccak256(abi.encodePacked(block.timestamp,\r\n                                          msg.sender,\r\n                                          randNonce))) % \r\n                                          modulus; \r\n         require(msg.sender == _owner, \"Caller is not owner\");\r\n         \r\n        // The list of players must be less than two\r\n         require( _playinggames[_gameid].playerscount < 2 == true, \"Only two players can play\");       \r\n         require(gamewithplayer[_gameid][playersaddress] != __gameid, \"Player already is set in game\");      \r\n        \r\n          gamewithplayer[_gameid][playersaddress] = __gameid;\r\n          uint _duration = block.number + maxWaitTime;\r\n         playerinthegame = PlayingGame(_gameid, playersaddress, false, 0,0, _duration);\r\n        \r\n         // Setting into memory          \r\n               \r\n         _playinggames[_gameid].playinggameid = _gameid;\r\n        _playinggames[_gameid].playerininaddress = playersaddress;\r\n        _playinggames[_gameid].gameover = false;\r\n        _playinggames[_gameid].gamescore = 0;\r\n        _playinggames[_gameid].playerscount = _playerscount;\r\n        _playinggames[_gameid].duration = _duration;\r\n         // Setting into storage\r\n         gameinplay.push(playerinthegame);\r\n \r\n       return(_gameid, playersaddress);  \r\n       }\r\n\r\n    function _checkplayerregistered(address payable _playeraddress) public returns (bool ) {\r\n              require(playersplayed[_playeraddress] == _playeraddress );\r\n              return(true);\r\n        }\r\n        function _checkgameregistered(uint _gameid) public returns (bool) {\r\n            require(gamesplayed[_gameid]== _gameid);\r\n            return(true);\r\n        } \r\n\r\n        function _checkplayeringame(uint  _gameid,address _playeraddress ) public returns (bool){\r\n            require( gamewithplayer[_gameid][_playeraddress] == _gameid );\r\n             return (true);\r\n        }\r\n  //Let's play game\r\n    function selectRock( ) public virtual  returns(bool)\r\n   { \r\n     \r\n     if (rockchosen){\r\n          rockchosen = true;\r\n           return (rockchosen); \r\n     }else{\r\n        rockchosen = false;\r\n         return (rockchosen);\r\n     }         \r\n       \r\n     }\r\n\r\n    function selectPaper() public virtual  returns(bool)\r\n     { if (paperchosen){\r\n          paperchosen = true; \r\n           return (paperchosen);\r\n     }else{\r\n        paperchosen = false;\r\n         return (paperchosen);\r\n     }         \r\n      \r\n     }\r\n    function selectScissors(  ) public virtual  returns(bool){\r\n     if (scissorschosen){\r\n          scissorschosen = true;\r\n          return (scissorschosen); \r\n     }else{\r\n        scissorschosen = false;\r\n        return (scissorschosen);\r\n     }         \r\n       \r\n     }\r\n\r\n    function stakeprevwinnings( ) public virtual  returns(bool) {\r\n         if(setprevwinnings) {\r\n           setprevwinnings =true;\r\n         }else{\r\n           setprevwinnings =false;\r\n         }\r\n    \r\n   \r\n    return (setprevwinnings);\r\n    }\r\n \r\n   function choosegametostake(uint game_id,address payable _playeraddress ) public virtual   returns(uint256){\r\n    prev_gamestaked =game_id;\r\n     if (stakeprevwinnings( ) ==true ){\r\n      uint256 winnings =0;\r\n     winnings  =    prev_winning[prev_gamestaked][_playeraddress];\r\n     transfer(_owner, winnings);\r\n     return( winnings);\r\n    }\r\n    }\r\n    /*\r\n    function compare(string memory choicemade, string memory chosenactmade) public returns(bool){\r\n        require (choicemade =chosenactmade, \"You did not win!\");\r\n        return (true);\r\n    \r\n    }\r\n    */\r\n    \r\n   event eventplaygame(uint  _eventgameid, address payable _eventtheplayeraddress, string   _eventchoicemade);\r\n   \r\n   function playgame(uint _gameid, address payable _theplayeraddress, string memory _choicemade ) internal returns(string memory, address, string memory){\r\n       \r\n       // Access Controls\r\n       require(msg.sender == _owner , \"Caller is not owner\");\r\n       _checkplayerregistered(_theplayeraddress);\r\n       _checkgameregistered( _gameid);\r\n       _checkplayeringame( _gameid ,_theplayeraddress ); \r\n       choosegametostake(prev_gamestaked, _theplayeraddress );\r\n       \r\n       for (uint i=0; i<2; i++){  \r\n        \r\n           choicemade = _choicemade;\r\n            if (selectRock() == true ){\r\n               scissorschosen = false;\r\n                paperchosen = false;\r\n          \r\n             choicemade = \"rock\" ;\r\n             }\r\n           if (selectPaper()== true ){\r\n              rockchosen = false;\r\n              scissorschosen = false;\r\n           \r\n             choicemade = \"paper\" ;\r\n             }\r\n             \r\n            if (selectScissors()== true ){\r\n            rockchosen =false;\r\n           paperchosen =false;\r\n             choicemade = \"scissors\" ;\r\n             }\r\n             continue; \r\n\r\n           \r\n\r\n   string[] memory choices;\r\n     choices[0] =\"rock\";\r\n     choices[1]=\"paper\";\r\n     choices[2]=\"scissors\";\r\n        // We create a random number generator for the values to be able to pick from\r\n        \r\n        uint shuffler = 0;\r\n        shuffler= 3;\r\n        uint _gameindex = 0;\r\n         randNonce++; \r\n        _gameindex =   uint(keccak256(abi.encodePacked(block.timestamp,\r\n                                          msg.sender,\r\n                                          randNonce))) % \r\n                                          shuffler; \r\n      \r\n    string memory choice = choices[_gameindex];  \r\n    //  const choice = Math.floor(Math.random() * choices.length);\r\n   // const choice = safemath.mod(choices, choices.length)\r\n      \r\n    if (StringUtils.equal(choicemade, choice)== true ){\r\n     \r\n        approve( _theplayeraddress, 10000);\r\n        transfer(_theplayeraddress,10000);\r\n        // _owner.transfer(_theplayeraddress,10000);\r\n          balanceOf(_theplayeraddress);\r\n          newplayerregistered.playeraddress =_theplayeraddress;\r\n       prev_winning[_gameid][_theplayeraddress] =10000; \r\n\r\n     \r\n       _playerstore[_theplayeraddress].playerscore +=5;  \r\n    }        \r\n  \r\n  emit eventplaygame( _gameid, _theplayeraddress,  _choicemade);\r\n    }\r\n    \r\n    }\r\n     \r\n     function totalSupply() public view virtual override  returns (uint256) {\r\n        return totalsupplytokens;\r\n    }\r\n   \r\n function balanceOf(address account) public view override  returns (uint256) {\r\n        return balances[account];\r\n    }\r\n  \r\n function owner() public view virtual override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\nfunction mint (address account, uint256 amount) external   virtual  returns (address, uint ) {\r\n      _mint( msg.sender,  amount);\r\n return(  account,  amount);\r\n}\r\n\r\nfunction burn (address account, uint256 amount) external   virtual returns (address, uint ) {\r\n      _burn( msg.sender ,  amount);\r\n return(  account,  amount);\r\n}\r\n\r\n\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/libraries/StringUtils.sol": {
      "content": "library StringUtils {\r\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\r\n    /// @return a negative number if `_a` is smaller, zero if they are equal\r\n    /// and a positive numbe if `_b` is smaller.\r\n    function compare(string memory _a, string memory _b) public returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n    /// @dev Compares two strings and returns true iff they are equal.\r\n    function equal(string memory _a, string memory _b) public returns (bool) {\r\n        return compare(_a, _b) == 0;\r\n    }\r\n    /// @dev Finds the index of the first occurrence of _needle in _haystack\r\n    function indexOf(string memory _haystack, string memory _needle) public returns (int)\r\n    {\r\n    \tbytes memory h = bytes(_haystack);\r\n    \tbytes memory n = bytes(_needle);\r\n    \tif(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n    \t\treturn -1;\r\n    \telse if(h.length > (2**128 -1)) // since we have to be able to return -1 (if the char isn't found or input error), this function must return an \"int\" type with a max length of (2^128 - 1)\r\n    \t\treturn -1;\t\t\t\t\t\t\t\t\t\r\n    \telse\r\n    \t{\r\n    \t\tuint subindex = 0;\r\n    \t\tfor (uint i = 0; i < h.length; i ++)\r\n    \t\t{\r\n    \t\t\tif (h[i] == n[0]) // found the first char of b\r\n    \t\t\t{\r\n    \t\t\t\tsubindex = 1;\r\n    \t\t\t\twhile(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) // search until the chars don't match or until we reach the end of a or b\r\n    \t\t\t\t{\r\n    \t\t\t\t\tsubindex++;\r\n    \t\t\t\t}\t\r\n    \t\t\t\tif(subindex == n.length)\r\n    \t\t\t\t\treturn int(i);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\treturn -1;\r\n    \t}\t\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n//pragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}